"""
Molt Promotion Discipline Engine.
Checks: multi-day stability, regime consistency, blocked-trade impact, shadow uplift persistence.
No automatic promotion. Proposal only.
"""
from __future__ import annotations

from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Any, Dict, List, Optional

REPO = Path(__file__).resolve().parents[1]


def _check_multi_day_stability(date: str, base: Path, days: int = 3) -> Dict[str, Any]:
    """Require N days of consistent attribution data."""
    reports_dir = base / "reports"
    from datetime import datetime as dt
    try:
        d = dt.strptime(date, "%Y-%m-%d")
    except Exception:
        return {"pass": False, "reason": "Invalid date"}
    found = 0
    for i in range(days):
        check_date = (d - timedelta(days=i)).strftime("%Y-%m-%d")
        p = reports_dir / f"SNAPSHOT_OUTCOME_ATTRIBUTION_{check_date}.md"
        if p.exists() and p.stat().st_size > 100:
            found += 1
    return {"pass": found >= 1, "reason": f"{found}/{days} days have attribution", "days_checked": days}


def _check_regime_consistency(date: str, base: Path) -> Dict[str, Any]:
    """Best-effort: regime mentioned in reports."""
    path = base / "reports" / f"SNAPSHOT_OUTCOME_ATTRIBUTION_{date}.md"
    if not path.exists():
        return {"pass": False, "reason": "No attribution report"}
    text = path.read_text(encoding="utf-8", errors="replace")
    has_regime = "regime" in text.lower()
    return {"pass": True, "reason": "Regime data present" if has_regime else "Regime not explicitly checked"}


def _check_blocked_impact(date: str, base: Path) -> Dict[str, Any]:
    """Blocked-trade report exists and has structure."""
    path = base / "reports" / f"BLOCKED_TRADE_INTEL_{date}.md"
    if not path.exists():
        return {"pass": True, "reason": "No blocked intel; skip"}
    return {"pass": True, "reason": "Blocked-trade report present"}


def _check_shadow_persistence(date: str, base: Path) -> Dict[str, Any]:
    """Shadow comparisons present in attribution."""
    path = base / "reports" / f"SNAPSHOT_OUTCOME_ATTRIBUTION_{date}.md"
    if not path.exists():
        return {"pass": False, "reason": "No attribution"}
    text = path.read_text(encoding="utf-8", errors="replace")
    has_shadow = "Shadow comparisons" in text or "shadow" in text.lower()
    return {"pass": has_shadow, "reason": "Shadow comparisons present" if has_shadow else "No shadow data"}


def run_promotion_discipline(
    date: str,
    base_dir: Optional[Path] = None,
) -> Dict[str, Any]:
    """
    Run promotion discipline checks. No automatic promotion.
    Returns dict of check results.
    """
    base = base_dir or REPO
    reports_dir = base / "reports"
    checks = {
        "multi_day_stability": _check_multi_day_stability(date, base),
        "regime_consistency": _check_regime_consistency(date, base),
        "blocked_impact": _check_blocked_impact(date, base),
        "shadow_persistence": _check_shadow_persistence(date, base),
    }
    all_pass = all(c.get("pass", False) for c in checks.values())
    out_path = reports_dir / f"PROMOTION_DISCIPLINE_{date}.md"
    lines = [
        f"# Promotion Discipline â€” {date}",
        "",
        f"**Generated:** {datetime.now(timezone.utc).isoformat()}",
        "**NO-APPLY.** No automatic promotion. Human approval required.",
        "",
        "## Checks",
        "",
        "| Check | Pass | Reason |",
        "|-------|------|--------|",
    ]
    for name, c in checks.items():
        p = "Yes" if c.get("pass") else "No"
        r = c.get("reason", "")[:60]
        lines.append(f"| {name} | {p} | {r} |")
    lines.extend([
        "",
        f"**Overall:** {'PASS' if all_pass else 'FAIL'}",
        "",
        "---",
        "*Generated by moltbot/promotion_discipline.py*",
    ])
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text("\n".join(lines), encoding="utf-8")
    return {"all_pass": all_pass, "checks": checks}
